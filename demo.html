<!DOCTYPE html>
<html><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>d3.js ~ Force-Directed Graph</title>
    <link rel="stylesheet" type="text/css" href="lib/jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css">
    <link rel="Stylesheet" href="lib/jqueryui/css/ui.selectmenu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.1/css/jquery.dataTables_themeroller.css">
    <link rel="stylesheet" type="text/css" href="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.3/css/jquery.dataTables.css">
    <link rel="stylesheet" type="text/css" href="lib/qtip/jquery.qtip.css">

    <!-- <link rel="stylesheet" type="text/css" href="DataTables-1.9.3/media/css/jquery.dataTables_themeroller.css"> -->
    <style type="text/css">
    html,body{ 
      height: 100%; 
      padding: 0;
      margin: 0;
    }
    h2,h3, h4 { margin-top: 0; margin-bottom: 0; padding-top: 0; padding-bottom: 0;}
    #headertabs { 
      width: 69%; 
      float: left; 
      height: 85%; 
      margin-left: 0px; 
      margin-right: 0px; 
      border-width: 0;
      background-color: white; }
    #heatmapTab {
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 55px;
    padding-bottom: 20px;
/*    border: 1px solid #aaa;
*/    overflow: none;
    }

    #heatmapTab div {
      float: left;
      /*display: inline-block;*/
    }


/* PATH TAB CONFIGURATION */

    #pathTab {
      margin-top: 10px;
    }

    .nodeTableImg {
      width: 20px;
      height: 20px;
      margin-right: 5px;
      vertical-align: middle;
    }


/* 
    HEATMAP CONFIGURATION
*/
  .sampleclass_container {
    float: left;
  }

  #categorical_container {
  }

  .numerical_container {
    padding-left: 10px;
  }

  #categoricalTable {
    empty-cells: show;
    height: 100%;
    border-collapse:collapse;
    table-layout: fixed;
  }

  #sampleClassTable tbody, #categoricalTable tbody, #numericalTable tbody {
    border-width: 1px;
    border-style: solid;
    border-color: gray;
  }

  #sampleClassText {
    text-align: center;
    position: relative;
    left: 0%;
    bottom: 20px;
  }

/*  #categoricalTable tbody td {
    border-width: 1px;
    border-style: solid;
    border-color: gray;    
  } */

/*#categoricalTable th, #numericalTable th {*/
  .nodeLabelHeader {
    font-family:Trebuchet MS, Arial, Helvetica;
    font-size: 10px;
    font-weight: normal;
    position: relative;
    height: 30px;
    bottom: 6px;
    left: 50%;
    transform: rotate(-40deg);
    transform-origin: 0% 50%;
    -ms-transform: rotate(-40deg); /* IE 9 */
    -ms-transform-origin:0% 50%; /* IE 9 */
    -webkit-transform: rotate(-40deg); /* Safari and Chrome */
    -webkit-transform-origin:0% 50%; /* Safari and Chrome */
    -moz-transform: rotate(-40deg); /* Firefox */
    -moz-transform-origin:0% 50%; /* Firefox */
    -o-transform: rotate(-40deg); /* Opera */
    -o-transform-origin:0% 50%; /* Opera */
  }

  #numericalTable {
    empty-cells: show;
    height: 100%;
    border-collapse:collapse;
    table-layout: fixed;
  }

  .nodeTypeFooter {
  /*#numericalTable tfoot td, #categoricalTable tfoot td { */
/*    width: 50px;*/
    font-family:Trebuchet MS, Arial, Helvetica;
    font-size: 11px;
    font-weight: normal;
    text-align: left;
    position: relative;
    height: 30px;
    top: 20px; /* from the tfoot td top */
    left: 50%;
    transform: rotate(-90deg);
    transform-origin: 30% 45%;
    -ms-transform: rotate(-90deg); /* IE 9 */
    -ms-transform-origin:30% 45%; /* IE 9 */
    -webkit-transform: rotate(-90deg); /* Safari and Chrome */
    -webkit-transform-origin:30% 45%; /* Safari and Chrome */
    -moz-transform: rotate(-90deg); /* Firefox */
    -moz-transform-origin:30% 45%; /* Firefox */
    -o-transform: rotate(-90deg); /* Opera */
    -o-transform-origin:30% 45%; /* Opera */
    margin-bottom: 40px;
  }

  #sampleClassTable {
    empty-cells: show;
    height: 100%;
    border-collapse:collapse;
    table-layout: fixed;    
  }

  #sampleClassTable td {
/*    border-width: 1px;
    border-style: solid;
    border-color: gray;        
*/  }

  #sampleClassTable thead {
    font-size: 11px;
    padding-left: 1px;
  }

/* 
  HEATMAP CONFIGURATION ENDS
*/


    #filter { padding-top: 0; padding-bottom: 0; margin-top: 0; margin-bottom: 0;}
    .container { width: 100%; height: 100%; margin-top: 0px; margin-bottom: 0px; }
    #sidebar { width: 30%; float: right; height: 100%; vertical-align: top;}
    .sidetab { font-size: small; }
    div.sidetab#plot { 
      height: 300px;
      padding-left: 0;
      padding-right: 0;
      overflow: hidden;
      /*padding-bottom: 60px;*/
      padding-top: 0px; 
    }
    div.sidetab#boxplotinfo {
      text-align: center;
      height: 300px;
      padding-left: 0;
      padding-right: 0;
      overflow: hidden;
      padding-bottom: 0px;
      padding-top: 0px; 
    }
    /* override default padding: */
    .ui-accordion .ui-accordion-content { 
    } 
    .link { stroke: #000000; }
    .filterTab { font-size: 12px; padding-left: 0px; padding-right: 0px; padding-top: 30px; padding-bottom: 10px;}

    .nodetext { pointer-events: none; font: 12px sans-serif; fill: #009933; font-weight: bold; }

    .ui-widget {font-size: 14px;}
    #datasetSelection { width: 200px; }

    select[name="nodeName"] { width: 300px;}
    .ui-dialog-titlebar-close { visibility: visible;}

    /* nodetype fields should be wide enough */
    select[class="nodeType"] { width: 70px;}

    #heatmapTab.ui-tabs-panel { height: 90%; }

    .ui-widget-header#sidebar {
        width: 90%;
    }

    .ui-widget-header {
        background: #cccccc;
        color: #222222;
        font-weight: bold;
        height:20px      
    }

    .ui-widget-header ul {
        height:18px;   
    }

    .ui-tabs .ui-tabs-nav li {
        height:18px;
        font-size:14px;
        
    }

    .ui-tabs .ui-tabs-nav li a {
        position:relative;
        top:-6px  
    }

    /* override style for header tabs, no grey bg */
.ui-widget-content#headertabs { border: 0px solid #aaaaaa; background: #ffffff 50% 50% repeat-x; color: #222222; }

/* displaying selected row in tables */
table.display tr.even.row_selected td {
  background-color: #B0BED9;
}

table.display tr.odd.row_selected td {
  background-color: #9FAFD1;
}


/* boxplot css */
.box { font: 10px sans-serif; }
.box line, .box rect, .box circle { stroke: #000; stroke-width: 1.5px; fill: #fff; }
.box .center { stroke-dasharray: 3 3; }
.box .outlier { stroke: #ccc; fill: none; }

/* drawing to hidden tabs will fail otherwise */
.ui-tabs .ui-tabs-hide {
    position: absolute;
    left: -10000px;
}

    </style>
    <script type="text/javascript" charset="utf8" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.8.1/jquery.min.js"></script>
    <script type="text/javascript" charset="utf8" src="http://cdnjs.cloudflare.com/ajax/libs/json2/20110223/json2.js"></script>
    <script type="text/javascript" charset="utf8" src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"></script>
    <script type="text/javascript" charset="utf8" src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.9.2/backbone-min.js"></script>
    <script type="text/javascript" charset="utf8" src="http://cdnjs.cloudflare.com/ajax/libs/backbone-localstorage.js/1.0/backbone.localStorage-min.js"></script>

    <!-- <script type="text/javascript" src="d3.v2.js"></script> -->

    <script type="text/javascript" charset="utf8" src="lib/jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
    <script type="text/javascript" charset="utf8" src="lib/jqueryui/js/jquery.ui.selectmenu.js"></script>
    <script type="text/javascript" charset="utf8" src="lib/jquery-multiopenaccordion/jquery.multi-accordion-1.5.3.js"></script>
    <script type="text/javascript" charset="utf8" src="http://ajax.aspnetcdn.com/ajax/jquery.templates/beta1/jquery.tmpl.min.js"></script>

    <script type="text/javascript" charset="utf8" src="lib/qtip/jquery.qtip.min.js"></script>

    <script type="text/javascript" charset="utf8" src="http://code.highcharts.com/highcharts.js"></script>
    <script type="text/javascript" src="http://d3js.org/d3.v2.min.js"></script>
    <script type="text/javascript" charset="utf8" src="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.3/jquery.dataTables.min.js"></script>

    <script type="text/javascript" charset="utf8" src="lib/mvc.js"></script>
    <script type="text/javascript" charset="utf8" src="lib/heatmap.js"></script>
    <script type="text/javascript" charset="utf8" src="lib/graph.js"></script>
    <script type="text/javascript" charset="utf8" src="lib/paths.js"></script>


    <!-- TEMPLATES FOR jQuery.tmpl: -->
    <script type="text/x-jquery-tmpl" id="clinicalSearchTmpl">
    <form>
      Start node: 
      <select name="nodeName">
      {{each clinNodes}}
        <option value="${$index}">${$value}</option>
      {{/each}}
      </select>
      Traversal depth:
      <select id="depth" size="1">
        <option>1</option>
        <option>2</option>
        <option selected="selected">3</option>
        <option>4</option>
      </select>

      <select id="firstEdgeType" size="1" class="nodeType">
        <option selected="selected">Any</option>
        <option>CLIN</option>
        <option>GEXP</option>
        <option>CNVR</option>
        <option>METH</option>
        <option>GNAB</option>
        <option>SAMP</option>
        <option>MIRN</option>
        <option>RPPA</option>
      </select>

      <select id="secondEdgeType" size="1" class="nodeType">
        <option selected="selected">Any</option>
        <option>CLIN</option>
        <option>GEXP</option>
        <option>CNVR</option>
        <option>METH</option>
        <option>GNAB</option>
        <option>SAMP</option>
        <option>MIRN</option>
        <option>RPPA</option>
      </select>

      <br>
      Nodes per layer:
      <select id="nodes" size="1">
        <option>5</option>
        <option>6</option>
        <option>7</option>
        <option>8</option>
        <option>9</option>
        <option>10</option>
      </select>
      <br>
      Ordering criterion:
      <select id="edgeOrderingAttribute" size="1">
        <option selected="selected">pvalue</option>
        <option>distance</option>
        <option>correlation</option>
        <option>importance</option>
      </select>
      <select id="edgeOrdering" size="1">
        <option selected="selected">DESC</option>
        <option>ASC</option>
      </select>
      <br>
      <input id="searchButton" type="submit" value="Search">
      </form>
    </script>


    <script type="text/x-jquery-tmpl" id="regulatorySearchTmpl">
      <p>Show
        <select id="sourceNodeType" size="1" style="width: 200px;">
          <option id="METH">Methylated</option>
          <option id="GNAB" type="aberrated">Aberrated</option>
          <option id="GNAB" type="functionallyMutated">Functionally mutated</option>
          <option id="CNVR">Copy-number altered</option>
          <option id="MIRN">miRNA-silenced</option>
        </select>

        <select id="middleNodeType" size="1">
          <option id="GEXP">Genes</option>
          <option id="RPPA">RPPAs</option>
        </select>
        that affect
        <br />clinical parameter 
        <select name="nodeName">
        {{each clinNodes}}
          <option value="${$index}">${$value}</option>
        {{/each}}
        </select>        
      </p>
      <input id="searchButton" type="submit" value="Search">
    </script>


    <!-- /TEMPLATES -->

    <script type='text/javascript'>

    //@global
    var heatMapDrawn = false;
    var patientBarcodes = [];
    var patientSampleClassifications = [];
    var referenceNodeId;
    var labelMaxLength = 11;

    var createNodeLabel = function( nodeO )
    {
      return "chr " + nodeO.chr + ", " + nodeO.start + ":" + nodeO.end;
    };

    // call this whenever dataset is changed
    var updatePatientBarcodes = function () {
      $.ajax( {
        type: "POST",
        url: '/graph/getPatientBarcodes',
        // wait for this to complete
        async: false,
        data: JSON.stringify( { datalabel: $('select#datasetSelection > option:selected').val() } ),
        dataType: "json",
        contentType: "application/json",
        success: function( result )
        { 
          patientBarcodes = result.barcodes.split(":");
        }
      });
    };

    Number.prototype.toFixedDown = function(digits) {
      var n = this - Math.pow(10, -digits)/2;
      return n.toFixed(digits);
    }

    var truncateLabel = function(label)
    {
      if( label )
      {
        return label.length > labelMaxLength ? label.substr(0,labelMaxLength - 3) + "..." : label;
      }
      return "";
    };

    // add functionality to primitives:
    Array.max = function( array ){
        return Math.max.apply( Math, array );
    };

    Array.min = function( array ){
        return Math.min.apply( Math, array );
    };

    Array.prototype.count = function( elementToFind )
    {
      return $.grep(this, function(elem) {
        return elem === elementToFind;
      }).length;
    };

    var orderObjectBy = function (name, minor) {
        return function (o, p) {
            var a, b;
            if (typeof o === 'object' && typeof p === 'object' && o && p) {
                a = o[name].toLowerCase();
                b = p[name].toLowerCase();
                if (a === b) {
                    return typeof minor === 'function' ? minor(o, p) : o;
                }
                if (typeof a === typeof b) {
                    return a < b ? -1 : 1;
                }
                return typeof a < typeof b ? -1 : 1;
            } else {
                throw {
                    name: 'Error',
                    message: 'Expected an object when sorting by ' + name
                };
            }
        }
    };

    // jquery function for uniqueness
    $.extend({
        distinct : function(anArray, removeNAs) {
           var result = [];
           $.each(anArray, function(i,v){
               if ( $.inArray(v, result) == -1 ) 
                {
                  if( removeNAs ) 
                  {
                    if( v === 'NA' )
                    {
                      return true;
                    }
                  }
                    result.push(v);
                }
           });
           return result;
        }
    });    

    var removeMatching = function(originalArray, regex) {
        var j = 0;
        while (j < originalArray.length) {
            if (regex.test(originalArray[j]))
                originalArray.splice(j, 1);
            else
                j++;
        }
        return originalArray;
    };

    var getLinkStroke = function( edgeO )
    {
      return Number(edgeO.pvalue) * 0.4 + 3 || Number(4);
    };

    var parseArrays = function( arrayA, arrayB )
    {

      var resultArray = [];
      for( var i = 0; i < arrayA.length; ++i )
      {
        if( arrayA[i].toLowerCase() === 'na' || arrayB[i].toLowerCase() === 'na' )
        {
          continue;
        }
        resultArray.push( [ arrayA[i] * 1, arrayB[i] * 1 ] );
      }
      return resultArray;
    };

      var linkSelection = [];

      var clearLinkSidetabs = function()
      {
          $("#nodeA.sidetab").html('');
          $("#nodeB.sidetab").html('');
          $("#link.sidetab").html('');
          $("#plot.sidetab").html('');
          $('#plot').prev('h3').find('a').text('Plot');
          $('#plot').css('padding-left', '');

          $('#boxplotinfo').prev('h3').css("display", "none");
          $('#boxplotinfo').html("");

          $('#sidebar').delay(600).multiAccordion( { 'active': 0 } );
      };

    var initBB_BC_CCPlot = function( sourcePatientValues, targetPatientValues, sourceLabel, targetLabel )
    {
      var labelMaxLength = 13;
      var categories;

      var getCategories = function( array1, array2, label1, label2 )
      {
        var categoryCounts = {};
        var result = {};
        var originalNames = {};
        var categoryName;
        var stringArr;
        var ele2;
        var catName;

        // calculate categories (something-something)
        $.each( array1, function(ind, ele1) 
        {
          ele2 = array2[ind];
          if( ele1.toLowerCase() === 'na' || ele2.toLowerCase() === 'na' ) return true;

          // use weird attaching character to avoid collisions in hash map
          categoryName = ele1 + "___" + ele2;
          !categoryCounts.hasOwnProperty( categoryName ) ? categoryCounts[ categoryName ] = Number(0) : categoryCounts[ categoryName ]++;
        });

        // construct final strings and percentages
        $.each( categoryCounts, function(cat, count)
        {
          stringArr = cat.split("___");
          catName = truncateLabel(label1) + "(<b>" + truncateLabel(stringArr[0]) + "</b>) <br> and " + truncateLabel(label2) + "(<b>" + truncateLabel(stringArr[1]) + "</b>)";
          
          // use count value instead of percentages
          result[ catName ] = count;
          //result[ catName ] = Math.round( ( count / array1.length ) * 100 );
          originalNames[ catName ] = label1 + "(<b>" + stringArr[0] + "</b>) <br> and " + label2 + "(<b>" + stringArr[1] + "</b>)";
        });
        return { categories: result, originalNames: originalNames };
      };
      var chartConfig = 
      {
              exporting: {
                enabled: false
              },
              chart: {
                  renderTo: 'plot',
                  type: 'bar',
                  marginRight: 150,
                  // margin: [0,0,0,0]
              },
              title: {
                text: null
                // enable: false
              },
              xAxis: {
                  categories: [],
                  title: {
                      text: 'Combination',
                      align: 'middle'
                  },
                  labels: {
                    overflow: 'justify'
                  },
              },
              yAxis: {
                  // use for percentages:
                  // min: 0,
                  // max: 100,
                  title: {
                      text: 'Count',
                      align: 'middle'
                  },
                  labels: {
                      overflow: 'justify'
                  }
              },
              tooltip: {
                formatter: function() { 
                  return this.point.originalLabel;
                }
              },
              plotOptions: {
                  bar: {
                      dataLabels: {
                          enabled: true
                      }
                  }
              },
              legend: {
                  layout: 'vertical',
                  align: 'right',
                  verticalAlign: 'top',
                  x: -10,
                  y: 10,
                  floating: true,
                  borderWidth: 1,
                  backgroundColor: '#FFFFFF',
                  shadow: true
              },
              credits: {
                  enabled: false
              },
              series: [{ name: '', data: [] }]
          };

          // truncate labels, they might be too long. tooltip will show it in full

      categories = getCategories( sourcePatientValues, targetPatientValues, sourceLabel, targetLabel );

      chartConfig.series[0]['name'] = "<b>" + truncateLabel( sourceLabel ) + "</b>,<br> and <br><b>" + truncateLabel( targetLabel ) + "</b>";

      chartConfig.xAxis['categories'] = d3.keys( categories.categories ).sort( function(a,b) { return categories.categories[a] < categories.categories[b] } );
      $.each( chartConfig.xAxis['categories'], function( ind, cat )
      {
        chartConfig.series[0].data.push( { y: categories.categories[cat], originalLabel: categories.originalNames[cat] } );
      });

      // render
      chart = new Highcharts.Chart(chartConfig);
    };

    var initBoxPlotInfo = function( categoricalValues )
    {
      var chart;
      var series = {};
      var category;
      var classification;
      var percentage;

      var categoryEmpty = function( catCounts, categoryName )
      {
        var keys = d3.keys(catCounts);
        for( var i = 0; i < keys.length; ++i )
        {
          if( catCounts[ keys[i] ][categoryName] > 0 )
          {
            return false;
          }
        }
        return true;
      };

      var nonEmptyCategories = function( catCounts )
      {
        var array = [];
        $.each( d3.values(catCounts)[0], function(key,count)
        {
          if( key !== "_count" && !categoryEmpty( catCounts, key ))
          {
            array.push( key );
          }
        });
        return array;
      };

      var chartConfig = 
      {
              exporting: {
                enabled: false
              },
              chart: {
                  renderTo: 'boxplotinfo',
                  type: 'bar',
                  // margin: [0,0,0,0]
              },
              title: {
                text: null
                // enable: false
              },
              xAxis: {
                  //categories: $.distinct( patientSampleClassifications, false ),
                  title: {
                      text: 'Sample class',
                      align: 'middle'
                  },
                  labels: {
                    overflow: 'justify'
                  },
              },
              yAxis: {
                  min: 0,
                  max: 100,
                  title: {
                      text: 'Percent',
                      align: 'middle'
                  },
                  labels: {
                      overflow: 'justify'
                  }
              },
              tooltip: {
                formatter: function() { return false; }
              },
              plotOptions: {
                  bar: {
                      dataLabels: {
                          enabled: true
                      }
                  }
              },
              legend: {
                  layout: 'vertical',
                  align: 'right',
                  verticalAlign: 'top',
                  x: -40,
                  y: 20,
                  floating: true,
                  borderWidth: 1,
                  backgroundColor: '#FFFFFF',
                  shadow: true
              },
              credits: {
                  enabled: false
              },
              series: []
          };

          // create series for each category
          //["PCaN", "PCaP", "CRPC", "BPH"]
          //[0.2, 0.2, 0.2, 0.4]

          // initialize structure:
          var categoryCounts = {};
          $.each( $.distinct( categoricalValues, true ), function(ind, category)
          {
            categoryCounts[ String( category ) ] = {};
            $.each( patientSampleClassifications, function( indP, classification )
            {
              categoryCounts[String(category)][classification] = Number(0);
              categoryCounts[String(category)]["_count"] = Number(0);
            });
          });

          // var classificationCount = Number(0);
          $.each( d3.zip( categoricalValues, patientSampleClassifications ), function(ind, pair)
          {
            category = String(pair[0]);
            classification = pair[1];
            if( category.toLowerCase() !== 'na' )//&& classification.toLowerCase() !== 'na' )
            {
              categoryCounts[ category ][ classification ] += 1;
              categoryCounts[String(category)]._count += 1;
            }
          });
          $.each( categoryCounts, function(cat,obj)
          {
            series = {};
            series['name'] = cat;
            series['data'] = [];
            $.each( obj, function(classif, count)
            {
              if( classif === "_count" ) return true;
              if( categoryEmpty( categoryCounts, classif ) ) return true;
              percentage = Math.round( ( count / obj._count ) * 100 );
              series.data.push( percentage );

            });
            chartConfig.series.push(series);
          });

          chartConfig.xAxis['categories'] = nonEmptyCategories(categoryCounts);

          // render
          chart = new Highcharts.Chart(chartConfig);
    };

    var initBoxPlot = function(numericValues, categoricalValues)
    {
        $('#plot').prev('h3').find('a').fadeOut( function() { $(this).text('Box Plot').fadeIn(); } );
        $('#plot').css('padding-left', 50);

        var margin = {top: 10, right: 50, bottom: 10, left: 50},
            width = 120 - margin.left - margin.right,
            height = 250 - margin.top - margin.bottom;

        var min = Infinity,
            max = -Infinity;

        var chart = boxChart()
            .whiskers(iqr(1.5))
            .width(width)
            .height(height);


        // put each each valueset into its own dataset
        // var categories = $.distinct( categoricalValues );
        var dataDict = {};
        var data = [];

        $.each( $.distinct( categoricalValues, true ), function(ind,category)
        {
          dataDict[ category ] = [];
        });

        $.each( numericValues, function(ind, value)
        {
          // if( categoricalValues[ind].toLowerCase() !== 'na' && !dataDict[ String( categoricalValues[ind] ) ] )
          //   {
          //     dataDict[ String( categoricalValues[ind] ) ] = [];
          //   }
          if( !isNaN( value) && categoricalValues[ind].toLowerCase() !== 'na' )
            {
              dataDict[ categoricalValues[ind] ].push( Number(value) );
            }
        });
        $.each( dataDict, function(ind, valueSet)
        {
          data.push( valueSet );
        });

        // init x- and y-xis
      //Create scale functions
      // var xScale = d3.scale.ordinal().domain(d3.range( d3.keys( dataDict ).length) ).range( d3.keys( dataDict ) );
      // var yScale = d3.scale.linear().range([max,min]);

      // var xAxis = d3.svg.axis().scale(xScale).ticks( d3.keys( dataDict ).length ).orient("left");
      // var yAxis = d3.svg.axis().scale(yScale).tickSize(-height).tickSubdivide(true);

        // open bar chart section
        if( patientSampleClassifications.length > 0 ) initBoxPlotInfo( categoricalValues );

        min = d3.min( $.map( data, function(n) { return n; } ) );
        max = d3.max( $.map( data, function(n) { return n; } ) );

        chart.domain([min, max]);

        var vis = d3.select("#plot").selectAll("svg")
            .data(data)
          .enter().append("svg")
            .attr("class", "box")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.bottom + margin.top)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .call(chart);

        // // Add the x-axis.
        // vis.append("svg:g")
        //     .attr("class", "boxplot-xaxis")
        //     .attr("transform", "translate(0," + height + ")")
        //     .call(xAxis);

        // // Add the y-axis.
        // vis.append("svg:g")
        //     .attr("class", "boxplot-yaxis")
        //     .attr("transform", "translate(" + width + ",0)")
        //     .call(yAxis);

        chart.duration(1000);
        window.transition = function() {
          vis.datum(randomize).call(chart);
        };

        function randomize(d) {
          if (!d.randomizer) d.randomizer = randomizer(d);
          return d.map(d.randomizer);
        }

        function randomizer(d) {
          var k = d3.max(d) * .02;
          return function(d) {
            return Math.max(min, Math.min(max, d + k * (Math.random() - .5)));
          };
        }

        // Returns a function to compute the interquartile range.
        function iqr(k) {
          return function(d, i) {
            var q1 = d.quartiles[0],
                q3 = d.quartiles[2],
                iqr = (q3 - q1) * k,
                i = -1,
                j = d.length;
            while (d[++i] < q1 - iqr);
            while (d[--j] > q3 + iqr);
            return [i, j];
          };
        }

        // Inspired by http://informationandvisualization.de/blog/box-plot
        function boxChart() {
          var width = 1,
              height = 1,
              duration = 0,
              domain = null,
              value = Number,
              whiskers = boxWhiskers,
              quartiles = boxQuartiles,
              tickFormat = null;

          // For each small multiple…
          function box(g) {
            g.each(function(d, i) {
              d = d.map(value).sort(d3.ascending);
              var g = d3.select(this),
                  n = d.length,
                  min = d[0],
                  max = d[n - 1];

              // Compute quartiles. Must return exactly 3 elements.
              var quartileData = d.quartiles = quartiles(d);

              // Compute whiskers. Must return exactly 2 elements, or null.
              var whiskerIndices = whiskers && whiskers.call(this, d, i),
                  whiskerData = whiskerIndices && whiskerIndices.map(function(i) { return d[i]; });

              // Compute outliers. If no whiskers are specified, all data are "outliers".
              // We compute the outliers as indices, so that we can join across transitions!
              var outlierIndices = whiskerIndices
                  ? d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n))
                  : d3.range(n);

              // Compute the new x-scale.
              var x1 = d3.scale.linear()
                  .domain(domain && domain.call(this, d, i) || [min, max])
                  .range([height, 0]);

              // Retrieve the old x-scale, if this is an update.
              var x0 = this.__chart__ || d3.scale.linear()
                  .domain([0, Infinity])
                  .range(x1.range());

              // Stash the new scale.
              this.__chart__ = x1;

              // Note: the box, median, and box tick elements are fixed in number,
              // so we only have to handle enter and update. In contrast, the outliers
              // and other elements are variable, so we need to exit them! Variable
              // elements also fade in and out.

              // Update center line: the vertical line spanning the whiskers.
              var center = g.selectAll("line.center")
                  .data(whiskerData ? [whiskerData] : []);

              center.enter().insert("svg:line", "rect")
                  .attr("class", "center")
                  .attr("x1", width / 2)
                  .attr("y1", function(d) { return x0(d[0]); })
                  .attr("x2", width / 2)
                  .attr("y2", function(d) { return x0(d[1]); })
                  .style("opacity", 1e-6)
                .transition()
                  .duration(duration)
                  .style("opacity", 1)
                  .attr("y1", function(d) { return x1(d[0]); })
                  .attr("y2", function(d) { return x1(d[1]); });

              center.transition()
                  .duration(duration)
                  .style("opacity", 1)
                  .attr("y1", function(d) { return x1(d[0]); })
                  .attr("y2", function(d) { return x1(d[1]); });

              center.exit().transition()
                  .duration(duration)
                  .style("opacity", 1e-6)
                  .attr("y1", function(d) { return x1(d[0]); })
                  .attr("y2", function(d) { return x1(d[1]); })
                  .remove();

              // Update innerquartile box.
              var box = g.selectAll("rect.box")
                  .data([quartileData]);

              box.enter().append("svg:rect")
                  .attr("class", "box")
                  .attr("x", 0)
                  .attr("y", function(d) { return x0(d[2]); })
                  .attr("width", width)
                  .attr("height", function(d) { return x0(d[0]) - x0(d[2]); })
                .transition()
                  .duration(duration)
                  .attr("y", function(d) { return x1(d[2]); })
                  .attr("height", function(d) { return x1(d[0]) - x1(d[2]); });

              box.transition()
                  .duration(duration)
                  .attr("y", function(d) { return x1(d[2]); })
                  .attr("height", function(d) { return x1(d[0]) - x1(d[2]); });

              // Update median line.
              var medianLine = g.selectAll("line.median")
                  .data([quartileData[1]]);

              medianLine.enter().append("svg:line")
                  .attr("class", "median")
                  .attr("x1", 0)
                  .attr("y1", x0)
                  .attr("x2", width)
                  .attr("y2", x0)
                .transition()
                  .duration(duration)
                  .attr("y1", x1)
                  .attr("y2", x1);

              medianLine.transition()
                  .duration(duration)
                  .attr("y1", x1)
                  .attr("y2", x1);

              // Update whiskers.
              var whisker = g.selectAll("line.whisker")
                  .data(whiskerData || []);

              whisker.enter().insert("svg:line", "circle, text")
                  .attr("class", "whisker")
                  .attr("x1", 0)
                  .attr("y1", x0)
                  .attr("x2", width)
                  .attr("y2", x0)
                  .style("opacity", 1e-6)
                .transition()
                  .duration(duration)
                  .attr("y1", x1)
                  .attr("y2", x1)
                  .style("opacity", 1);

              whisker.transition()
                  .duration(duration)
                  .attr("y1", x1)
                  .attr("y2", x1)
                  .style("opacity", 1);

              whisker.exit().transition()
                  .duration(duration)
                  .attr("y1", x1)
                  .attr("y2", x1)
                  .style("opacity", 1e-6)
                  .remove();

              // Update outliers.
              var outlier = g.selectAll("circle.outlier")
                  .data(outlierIndices, Number);

              outlier.enter().insert("svg:circle", "text")
                  .attr("class", "outlier")
                  .attr("r", 5)
                  .attr("cx", width / 2)
                  .attr("cy", function(i) { return x0(d[i]); })
                  .style("opacity", 1e-6)
                .transition()
                  .duration(duration)
                  .attr("cy", function(i) { return x1(d[i]); })
                  .style("opacity", 1);

              outlier.transition()
                  .duration(duration)
                  .attr("cy", function(i) { return x1(d[i]); })
                  .style("opacity", 1);

              outlier.exit().transition()
                  .duration(duration)
                  .attr("cy", function(i) { return x1(d[i]); })
                  .style("opacity", 1e-6)
                  .remove();

              // Compute the tick format.
              var format = tickFormat || x1.tickFormat(8);

              // Update box ticks.
              var boxTick = g.selectAll("text.box")
                  .data(quartileData);

              boxTick.enter().append("svg:text")
                  .attr("class", "box")
                  .attr("dy", ".3em")
                  .attr("dx", function(d, i) { return i & 1 ? 6 : -6 })
                  .attr("x", function(d, i) { return i & 1 ? width : 0 })
                  .attr("y", x0)
                  .attr("text-anchor", function(d, i) { return i & 1 ? "start" : "end"; })
                  .text(format)
                .transition()
                  .duration(duration)
                  .attr("y", x1);

              boxTick.transition()
                  .duration(duration)
                  .text(format)
                  .attr("y", x1);

              // Update whisker ticks. These are handled separately from the box
              // ticks because they may or may not exist, and we want don't want
              // to join box ticks pre-transition with whisker ticks post-.
              var whiskerTick = g.selectAll("text.whisker")
                  .data(whiskerData || []);

              whiskerTick.enter().append("svg:text")
                  .attr("class", "whisker")
                  .attr("dy", ".3em")
                  .attr("dx", 6)
                  .attr("x", width)
                  .attr("y", x0)
                  .text(format)
                  .style("opacity", 1e-6)
                .transition()
                  .duration(duration)
                  .attr("y", x1)
                  .style("opacity", 1);

              whiskerTick.transition()
                  .duration(duration)
                  .text(format)
                  .attr("y", x1)
                  .style("opacity", 1);

              whiskerTick.exit().transition()
                  .duration(duration)
                  .attr("y", x1)
                  .style("opacity", 1e-6)
                  .remove();
            });
            d3.timer.flush();
          }

          box.width = function(x) {
            if (!arguments.length) return width;
            width = x;
            return box;
          };

          box.height = function(x) {
            if (!arguments.length) return height;
            height = x;
            return box;
          };

          box.tickFormat = function(x) {
            if (!arguments.length) return tickFormat;
            tickFormat = x;
            return box;
          };

          box.duration = function(x) {
            if (!arguments.length) return duration;
            duration = x;
            return box;
          };

          box.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x == null ? x : d3.functor(x);
            return box;
          };

          box.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return box;
          };

          box.whiskers = function(x) {
            if (!arguments.length) return whiskers;
            whiskers = x;
            return box;
          };

          box.quartiles = function(x) {
            if (!arguments.length) return quartiles;
            quartiles = x;
            return box;
          };

          return box;
        };

        function boxWhiskers(d) {
          return [0, d.length - 1];
        }

        function boxQuartiles(d) {
          return [
            d3.quantile(d, .25),
            d3.quantile(d, .5),
            d3.quantile(d, .75)
          ];
        }        


    }; // initBoxPlot
    

    var plotNodePatientValues = function( sourceNodeo, targetNodeo, edgeo )
    {
      console.log("source=" + sourceNodeo.type + ", target=" + targetNodeo.type );
      var openBoxPlotInfo = function()
      {
        if( patientSampleClassifications.length > 0 ) {
          $('#boxplotinfo').prev('h3').css("display", "");
          $('#sidebar').multiAccordion( { 'active': [3,4,5] } );
          $('#boxplotinfo').prev('h3').css("display", "");
        }
        else
        {
          $('#sidebar').multiAccordion( { 'active': [3,4] } );
        }
      };

      $("#nodeA.sidetab").html( getNodeText(sourceNodeo) );
      $("#nodeB.sidetab").html( getNodeText(targetNodeo) );
      $("#link.sidetab").html( getLinkText(edgeo) );

      var sourcePatientValues = sourceNodeo.patientvals;//.split(":");
      var targetPatientValues = targetNodeo.patientvals;//.split(":");

      var sourceType = sourceNodeo.type.toLowerCase();
      var targetType = targetNodeo.type.toLowerCase();

      if( ( sourceType === 'n' && targetType === 'c' ) ||
        ( sourceType === 'n' && targetType === 'b' ) )
      {
        // open box plot info section
        openBoxPlotInfo();        
        setTimeout( function() { initBoxPlot( sourcePatientValues, targetPatientValues ); }, 450 );
        return;
      }
      else if( ( sourceType === 'c' && targetType === 'n' ) ||
        ( sourceType === 'b' && targetType === 'n' ) ) {
        // open box plot info section
        openBoxPlotInfo();
        setTimeout( function() { initBoxPlot( targetPatientValues, sourcePatientValues ); }, 450 );
        return;
      }
      else if( ( sourceType ===  'b' && targetType === 'b' ) || ( sourceType ===  'b' && targetType === 'c' ) ||
        ( sourceType ===  'c' && targetType === 'b' ) || ( sourceType ===  'c' && targetType === 'c' ) )
      {
        setTimeout( function() { initBB_BC_CCPlot( sourcePatientValues, targetPatientValues, sourceNodeo.label, targetNodeo.label ) }, 450 );
        $('#sidebar').multiAccordion( { 'active': [3,4] } );
        return;
      }
      $('#sidebar').multiAccordion( { 'active': [3,4] } );
      setTimeout( function() { initScatterplot( sourceNodeo, targetNodeo ); }, 450 );
    };

    var initScatterplot = function( sourceNodeo, targetNodeo ) //, patientBarcodes )
    {
        var sourcePlot = sourceNodeo.patientvals;//.split(":");
        var targetPlot = targetNodeo.patientvals;//.split(":");

        $('#plot').prev('h3').find('a').fadeOut( function() { $(this).text('Scatterplot').fadeIn(); } );
        var scatterplotData = [];
        var sampleSeries = {};
        var dataX, dataY;
        var colorpalette = d3.scale.category10();

      var scatterplotConfig = {
            chart: {
                renderTo: 'plot',
                type: 'scatter',
                zoomType: 'xy'
            },

            exporting: {
                buttons: { 
                    exportButton: {
                        enabled: false
                    },
                    printButton: {
                        enabled: false
                    }

                }
            },

            title: {
                text: 'Patient values'
            },
            // subtitle: {
            //     text: "(NodeA: " + patientValuesA.length + " values, NodeB: " + patientValuesB.length + " values)"
            // },
            xAxis: {
                title: {
                    enabled: true,
                    //text: 'Node A'
                },
                startOnTick: true,
                endOnTick: true,
                showLastLabel: true
            },
            yAxis: {
                title: {
                    //text: 'Node B'
                }
            },
            tooltip: {
                formatter: function() {
                  return "<b>Patient</b>: " + this.point.barcode;
                    //return "NodeA: " + this.x + "<br>NodeB: " + this.y;
                }
            },
            legend: {
                layout: 'vertical',
                align: 'left',
                verticalAlign: 'top',
                x: 55,
                y: 45,
                floating: true,
                backgroundColor: '#FFFFFF',
                borderWidth: 1
            },
            credits: {
                enabled: false
            },
            plotOptions: {
                scatter: {
                    marker: {
                        radius: 5,
                        states: {
                            hover: {
                                enabled: true,
                                lineColor: 'rgb(100,100,100)'
                            }
                        }
                    },
                    states: {
                        hover: {
                            marker: {
                                enabled: false
                            }
                        }
                    }
                }
            },
            series: []
    };

    scatterplotConfig.xAxis.title['text'] = sourceNodeo.source + " of " + sourceNodeo.label + ", chr " + sourceNodeo.chr;

    scatterplotConfig.yAxis.title['text'] = targetNodeo.source + " of " + targetNodeo.label + ", chr " + targetNodeo.chr;


    if( patientSampleClassifications.length > 0 ) // && samples.length === scatterplotData.length )
    {
      // classification for samples exists
      $.each( patientSampleClassifications, function(ind, sample)
      {
        if( !sampleSeries[sample] )
        {
          sampleSeries[sample] = [];
        }
        dataX = sourcePlot[ind]*1;
        dataY = targetPlot[ind]*1;
        if( !isNaN( dataX ) && !isNaN( dataY ) )
        {
        sampleSeries[sample].push( { 'x': dataX, 'y': dataY, 'barcode': patientBarcodes[ind] } );// scatterplotData[ind] );
        }
      });

      $.each( sampleSeries, function(seriesName, series )
      {
        scatterplotConfig.series.push( 
        {
          name: seriesName,
          color: colorpalette(seriesName),
          data: series
        });
      });
    }
    else
    {
      // no classification available
      $.each( patientBarcodes, function(ind, barcode )
      {
        dataX = sourcePlot[ind]*1;
        dataY = targetPlot[ind]*1;
        if( !isNaN( dataX ) && !isNaN( dataY ) )
        {
          scatterplotData.push( { 'x': dataX, 'y': dataY, 'barcode': barcode } );
        }
      });
      scatterplotConfig.series.push( 
      {
        name: "Dataset",
        color: 'rgba(223, 83, 83, .5)',
        data: scatterplotData
      });
    }
  
    var chart = new Highcharts.Chart( scatterplotConfig );
  }

var getNodeText = function(data)
{
  var html = "<b>Id:</b> " + data.id + "<br>";
  html += "<b>Label:</b> " + data.label + "<br>";
  html += "<b>Source:</b> " + data.source + "<br>";
  html += "<b>Chromosome:</b> " + ( data.chr || '-' ) + "<br>"; //+ "</p>";
  html += "<b>Start:</b> " + ( data.start || '-' ) + "<br>";
  html += "<b>End:</b> " + ( data.end || '-' ) + "<br>";
  if( data.hasOwnProperty('gene_interesting_score') )
  {
    html += "<b>Gene interesting score:</b> " + data.gene_interesting_score + "<br>";
  }
  return html;
};

var getLinkText = function(data)
{
  var html = "<b>Id:</b> " + data.id + "<br>";
  html += "<b>-log10(pvalue):</b> " + data.pvalue + "<br>";
  html += "<b>Importance:</b> " + data.importance + "<br>";
  html += "<b>Correlation:</b> " + data.correlation + "<br>";
  if( data.distance )
  {
    html += "<b>Chromosomal distance:</b> " + data.distance + "<br>";
  }
  return html;
};

    var initGraph = function( json, patientBarcodes )
    {
      var nodeImageW = 50;//50;
      var nodeImageH = 50;//50;

      // remove previous graph
      d3.select('#graphTab > svg').remove();

      // split patient values and form numbers
      var patientVal;
      $.each( json.nodes, function(ind,node)
      {
        json.nodes[ind].patientvals = node.patientvals.split(":");
      });
      // clear previous sidetabs:
      clearLinkSidetabs();
      linkSelection = [];

      // calculate max-min values for gene interesting scores:
      var maxScore = Math.max.apply( Math, json.nodes.map( function(o) { return o.gene_interesting_score; } ) );
      var minScore = Math.min.apply( Math, json.nodes.map( function(o) { return o.gene_interesting_score; } ) );
      var maxNodeSize = 240;
      var referenceNodeColor = "#FFEE00";

      // Prep the node IDs:
      // https://groups.google.com/forum/#!topic/d3-js/LWuhBeEipz4
      var hash_lookup = [];
      json.nodes.forEach(function(d, i) {
        hash_lookup[d.id] = d;
      });
      json.links.forEach(function(d, i) {
        d.source = hash_lookup[d.source];
        d.target = hash_lookup[d.target];
      });

      // canvas is set according to width/height
      var width = $(window).width() * 0.7 - 50; //- 50,
          height = $(window).height() *0.95 - 25;
      var r = 5;
      var trans=[0,0], scale=1;

      var link_def_opacity = 0.6;
      var node_def_opacity = 1.0;
      // var default_opacity = 0.6;

      var color = d3.scale.category20();
      var fill = d3.scale.category10();

      var force = d3.layout.force()
          .linkDistance( function(d) {
            if( d.hasOwnProperty('distance') )
            {
              return ( d.distance < 10000 ) ? ( Math.log(d.distance) / Math.log(10) ) * 2 + 30 : ( Math.log( d.distance ) / Math.log(10) ) * 13 + 5;
            }
            return 100;
          } )
          .linkStrength( 1 )
          .gravity(0.05)
          .charge(-150)
          // .charge(-1000)
          // .friction(0.2)
          // .gravity(0.30)
          .size([width, height]);



      var svg = d3.select('#headertabs > #graphTab').append("svg:svg")
          .attr("width", width)
          .attr("height", height)
          .attr("pointer-events", "all")
          .append('svg:g')
          // .attr('class', 'brush') 
          // .call(brush.x(brushX).y(brushY))
          .call(d3.behavior.zoom().translate([0,0]).scale(1.0).scaleExtent([0.1,4.0]).on("zoom", redraw))
          .append('svg:g');
      // append a white rectangle to background to use in zooming
      svg.append('svg:rect')
          .attr('width', width)
          .attr('height', height)
          .attr('fill', 'white');
          //.style('fill', '#eeeeee');
          //.style("stroke", "#000");


        var nodeLegend = d3.select('#headertabs > #graphTab > svg').append("svg:image")
        .attr("id", "nodeLegend")
        .attr("xlink:href", "img/legend_round.svg")
        .attr("width", 100)
        .attr("height", 300);

      // var nodeLegend = d3.select('#headertabs > #graphTab > svg')//.append("svg:svg")
      // // .attr("class", "nodeLegend")
      // // .attr("width", 150)
      // // .attr("height", 250)
      // .append("svg:rect")
      // .attr("width", 150)
      // .attr("height", 250)
      // .style("stroke", "gray")
      // .style("stroke-width", 1)
      // .style("fill", "white");

      // line markers
      svg.append("svg:defs").selectAll("marker")
      .data(["activating"])
      .enter().append("svg:marker")
      .attr("id", function(d) { 
        return d === "activating" ? "arrow-activating" : "arrow-inhibiting" 
      } )
      .attr("refX", 25)//function(d) { return Math.sqrt(120*2) })
      // // .attr("refY", 0)
      .attr("viewBox", "4 4 15 10")
      .attr("markerWidth", 20)
      .attr("markerHeight", 10)
      .attr("markerUnits", "userSpaceOnUse")
      .attr("orient", "auto")
      .attr("style", "overflow:visible")      
      .append("svg:path")
      .attr("d", "M 5.77,0.0 L -2.88,5.0 L -2.88,-5.0 L 5.77,0.0 z ")
      .attr("style", "fill-rule:evenodd;fill:#FFFFFF;stroke:#FF0000;stroke-width:2.0pt;marker-start:none; stroke-opacity: 0.8; stroke-dashrray: 0")
      .attr("translate", "scale(0.8)");
      // $('defs > marker[id="arrow-activating"] > path').css('stroke-dasharray', 0)

      // second line marker
      svg.append("svg:defs").selectAll("marker")
      .data(["inhibiting"])
      .enter().append("svg:marker")
      .attr("id", function(d) { 
        return d === "activating" ? "arrow-activating" : "arrow-inhibiting" 
      } )
      // .attr("viewBox", "0 -5 10 10")
      .attr("refX", 25)//function(d) { return Math.sqrt(120*2) })
      .attr("viewBox", "4 4 15 10")
      // // .attr("refY", 0)
      .attr("markerWidth", 20)
      .attr("markerHeight", 20)
      .attr("markerUnits", "userSpaceOnUse")
      .attr("orient", "auto")
      .attr("style", "overflow:visible")      
      .append("svg:path")
      // .attr("stroke", "none")
      // .attr("fill", "#FF3300")
      .attr("d", "M 0.0,5.65 L 0.0,-5.65")
      //.attr("d", "M0,-5L10,0L0,5")
      .attr("style", "fill:none;fill-opacity:0.75000000;fill-rule:evenodd;stroke:#FF0000;stroke-width:3.0pt; stroke-opacity: 0.8; stroke-dashrray: 0")
      .attr("translate", "scale(1.0)");


      // used for zooming
      function redraw() {
        // console.log("here", d3.event.translate, d3.event.scale);
        svg.attr( "transform", "translate(" + d3.event.translate[0] + "," + d3.event.translate[1] + ") scale(" + d3.event.scale + ")" );

        // svg.attr("transform",
        //     "translate(" + d3.event.translate + ")"
        //     + " scale(" + d3.event.scale + ")");
      }

      // colors selected nodes in red
      function color_node(node) {
            // console.log("color_node");
          if (node.selected) { return "red"; }
          else { return fill(node.group);}
      }

        force
            .nodes(json.nodes)
            .links(json.links)
            .size([width,height])
            .start();

        // converge
        // for(var i =0; i < force.nodes().length * 1000; ++i )
        // {
        //   force.tick();
        // }
      // force.start();
      for (var i = json.nodes.length * json.nodes.length * 3 + 1000; i > 0; --i) force.tick();
      // force.stop();


      function fade(opacity) {
          return function(d) {
            var thisOpacity;

            // return to default view
            if( opacity === node_def_opacity )
            {
              d3.selectAll('marker > path').transition().style("opacity", 1);
              // d3.selectAll('marker > path').transition().style('display', '');
              nodeGroup.transition().style("opacity", node_def_opacity);
              link.style("stroke-opacity", link_def_opacity);
            }
            else // fade not-neighborhood away
            {
              d3.selectAll('marker > path').transition().style("opacity", 0);
              // d3.selectAll('marker > path').transition().style('display', 'none');
              nodeGroup.transition().style("opacity", function(o)
              {
                thisOpacity = isConnected(d, o) ? node_def_opacity : opacity;
                return thisOpacity; 
              });

              link.style("stroke-opacity", function(o) {
                  return o.source === d || o.target === d ? link_def_opacity : opacity;
              });              
            }
          }
      }    

        //https://groups.google.com/forum/#!topic/d3-js/LWuhBeEipz4
        var link = svg.selectAll("line.link")
            .data(json.links )
          .enter().append("line")
            .attr("class", "link")
            .attr("id", function(d) { return d.id; } )
            // .style("stroke", "black")
            .style("stroke-width", 
              function(d) { return getLinkStroke( d ) } )
            .on("mouseover", function(d) {
              var selection = d3.select(this);
              var initialWidth = Number( selection.style("stroke-width") );
              selection.transition().style("stroke-width", initialWidth + Number(4) )
              .style("stroke-opacity", 1.0);
              //.style("stroke", linkOverColor);
            } )
            .on("mouseout", function(d) {
              var selection = d3.select(this);
              selection.transition().style("stroke-width", getLinkStroke( selection.data()[0] ) )
              .style("stroke-opacity", link_def_opacity);
            })
            .on("mousedown", function(d) {
              if( linkSelection.length > 0 )
              {
                if( linkSelection[0].id === this.id )
                {
                  d3.select( this ).style("stroke", "#000000");
                  linkSelection.pop()
                  clearLinkSidetabs();
                  return;
                }
                d3.select( linkSelection[0] ).style("stroke", "#000000");
                linkSelection.pop();
                clearLinkSidetabs();
              }

              d3.select(this).style("stroke", "#FFD700");
              linkSelection.push(this);


              var sourceData = d3.select(".nodeGroup#" + d.source.id).data()[0];
              var targetData = d3.select(".nodeGroup#" + d.target.id).data()[0];
              // var sourceData = d3.select( "path#" + d.source.id ).data()[0];
              // var targetData = d3.select( "path#" + d.target.id ).data()[0];
              plotNodePatientValues( sourceData, targetData, d );

            }) // mousedown
            .style("stroke-opacity", link_def_opacity )
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; })
            .attr("marker-end", function(d) { 
              return (d.correlation > 0) ? "url(#arrow-activating)" : "url(#arrow-inhibiting)";
            })
            .style("stroke-dasharray", function(d) { 
              if( d.distance )
              {
                return ( d.distance < 10000 ) ? "2, 3" : "none";
              }
              return "none";
            } )
            .call(force.drag);


        var getNodeTransformMatrix = function(d)
        {
          var matrix = "matrix(";
          var scale = 0.55; // sx & sy
          if( d.hasOwnProperty('gene_interesting_score') && d.gene_interesting_score > 0 )
          {
            scale = ( (d.gene_interesting_score - minScore ) / ( maxScore - minScore ) ) * 0.5 + 0.25; 
          }
          matrix += scale + ",0,0," + scale + "," + ( d.x - ( scale*nodeImageW/2 ) ) + "," + ( d.y - ( scale*nodeImageH/2 ) ) + ")";
          return matrix;          
        };

        // var node = svg.selectAll("image.node").data(json.nodes);
        var nodeGroup = svg.selectAll("image.node").data(json.nodes).enter()
        .append("svg:g")
        .attr("id", function(d) { return d.id; }) 
        .attr("class", "nodeGroup")
        .call(force.drag);

        var node = nodeGroup.append("svg:image")
        // .attr("viewBox", "0 0 300 300") // + nodeImageW + " " + nodeImageH)
        .attr("class", "node")
        .attr("xlink:href", function(d)
        {
          switch( d.source )
          {
            case "GEXP": return "img/node_gexp.svg";
            case "CNVR": return "img/node_cnvr.svg";
            case "METH": return "img/node_meth.svg";
            case "CLIN": return "img/node_clin.svg";
            case "GNAB": return "img/node_gnab.svg";
            case "MIRN": return "img/node_mirn.svg";
            case "SAMP": return "img/node_samp.svg";
            case "RPPA": return "img/node_rppa.svg";
          }
        })
        .attr("width", nodeImageW)
        .attr("height", nodeImageH)
        .attr("transform", function(d) { return getNodeTransformMatrix(d); } )
        .on("click", function(d) { 
          console.log("nodeclick");
          } )
        // display closest neighbors and fade others out
        .on("mouseover", fade(0.10) )
        // return to default view
        .on("mouseout", fade(node_def_opacity) );


        var nodeText = nodeGroup
        .append("svg:text")
          .attr("class", "nodetext")
          .attr("x", function(d) { return d.x } ) 
          .attr("y", function(d) { return d.y } ) 
          .attr("dx", "1.5em")
          //.attr("dy", "")
          .text( function(d) { return d.label; } );

        // color the reference node:
        d3.select(".nodeGroup#n" + referenceNodeId + "> text").style("fill", referenceNodeColor);


          var linkedByIndex = {};
          json.links.forEach(function(d) {
              linkedByIndex[d.source.index + "," + d.target.index] = 1;
          });          

          function isConnected(a, b) {
              return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
          }            


        force.on("tick", function() {

          link.attr("x1", function(d) { return d.source.x; })
              .attr("y1", function(d) { return d.source.y; })
              .attr("x2", function(d) { return d.target.x; })
              .attr("y2", function(d) { return d.target.y; });

          // move node to new position
          node.attr("transform", function(d) { return getNodeTransformMatrix(d); } );

          // mode nodeText to new position
          nodeText
          .attr("x", function(d) { return d.x } )
          .attr("y", function(d) { return d.y } ); 
    
        });

        // force.stop();
          for(var i = 0; i < force.nodes().length; ++i )
          {
            force.nodes()[i].fixed = true;
          }

          // quickfix: override path dashline property so markers are solid lines (chrome renders wrong?)
          $('defs > marker[id="arrow-activating"]').css('stroke-dasharray', "0");
          $('defs > marker[id="arrow-inhibiting"]').css('stroke-dasharray', "0");

}; // initgraph

      // dialog functions
      var openDialog = function( title, message )
      {
        $('#dialog').dialog('option', 'title', title);
        $('#dialog').html('<p>' + message + '</p>');
        $('#dialog').dialog("open");
      };

      var openTableDialog = function( title, message, aoNodes )
      {
        $('#dialog').html("<p>" + message + "</p>" );
        $('#dialog').dialog('option', 'title', title);
        // $('#dialog').dialog('option', 'width', '600');
        // $('#dialog').dialog('option', 'height', '600');

        $('#dialog').css("display", "block");
        $('#dialog').append( '<table id="dialogTable" cellpadding="0" cellspacing="0" border="0"></table>' );

        var oTable = $('#dialog > table').dataTable( {
            // "bFilter": false,
            // "bInfo": false,

            "bProcessing": true,
            "bAutoWidth": false,
            "aaData": aoNodes,
            "bJQueryUI": true,
            "sDom": '<"H"lfr>t<"F"Cip>',
            "aoColumns": [
                { "sTitle": "Id",
                  "mData": "id",
                  "sWidth": '50px' },
                { "sTitle": "Label",
                  "mData": "label",
                  "sWidth": '200px' },
                { "sTitle": "Chromosome",
                  "mData": "chr",
                  "sWidth": '50px' },
                { "sTitle": "Start",
                  "mData": "start",
                  "sWidth": '80px' },
                { "sTitle": "Source",
                  "mData": "source",
                  "sWidth": '80px' },
                { "sTitle": "Type",
                  "mData": "type",
                  "sWidth": '50px' }
            ]
        } );
        $('#dialog').dialog("open");        

      }

      var closeDialog = function() {
        $('#dialog').dialog("close");
        $('#dialog').html("");
      };

var initPaths = function()
{
  // if( !$('#pathTab').is(":empty") )
  // {
  //   // don't redraw
  //   return;
  // }

  var edges = d3.selectAll("line.link");
  var refNode = d3.select("#n" + referenceNodeId + ".nodeGroup").data()[0];

  var nodeLinkCatalog = {};
  var linkSourceDestCatalog = {};
  var pathLinks = [];
  var simplePaths = [];
  var visitedCatalog = {};
  var neighbor;
  var traversingStack = [];
  var leafs = Number(0);
  var shallowCopyObject = {};
  var pathCell = {};
  var maxPathLength = 0;
  var pathLength = 0;

  var getLinkHTML = function(linkO)
  {
    var html;
    html = "<b>pvalue</b>: " + linkO.pvalue.toFixedDown(2) + "<br/>";
    if( linkO.hasOwnProperty('distance') ) html += "<b>distance</b>: " + linkO.distance + "<br/>";
    html += "<b>correlation</b>: " + linkO.correlation.toFixedDown(2) + "<br/>";
    html += "<b>importance</b>: " + linkO.importance.toFixedDown(2) + "<br/>";
    return html;
  };

  var getNodeHTML = function(nodeO)
  {
    var html;
    var nodeSrc;
    switch( nodeO.source )
    {
      case "GEXP": 
        nodeSrc = "img/node_gexp.svg";
        break;
      case "CNVR":
        nodeSrc = "img/node_cnvr.svg";
        break;
      case "METH": 
        nodeSrc = "img/node_meth.svg";
        break;
      case "CLIN": 
        nodeSrc = "img/node_clin.svg";
        break;
      case "GNAB": 
        nodeSrc = "img/node_gnab.svg";
        break;
      case "MIRN":
        nodeSrc = "img/node_mirn.svg";
        break;
      case "SAMP": 
        nodeSrc = "img/node_samp.svg";
        break;
      case "RPPA": 
        nodeSrc = "img/node_rppa.svg";
        break;
    }
    // html = '<a href="testlink">JEA</a>';
    html = $('<img/>', { src: nodeSrc, class: 'nodeTableImg', title: nodeO.source } ).prop("outerHTML");
    //html = '<object data="' + nodeImg + '" type="image/svg+xml" class="nodeImage" aria-label="' + nodeO.source + '"></object>';
    //html = $('<object/>', { data: nodeImg, type: 'image/svg+xml', width: 15, height: 15 }).prop("outerHTML");
    html += nodeO.label;
    return html;
  };

  var dfs = function( nodeO )
  {
    visitedCatalog[nodeO.id] = 'gray';
    // console.log("push 1 to stack");
    //traversingStack.push( d3.select( "#" + nodeO.id + ".nodeGroup" ) );
    traversingStack.push(nodeO);
    // console.log("traversing stack l:" + traversingStack.length );
    if( nodeLinkCatalog.hasOwnProperty( nodeO.id ) )
    {
      $.each( nodeLinkCatalog[nodeO.id], function(ind,neighborEdge)
      {
        //traversingStack.push( d3.select("line#" + neighborEdge.id + ".link") );
        neighbor = neighborEdge.target;
        // console.log("looking at neighbor:");
        // console.log( d3.select("#" + neighbor.id  + ".nodeGroup" ) );

        // unvisited at the moment, 'white'
        if( !visitedCatalog.hasOwnProperty( neighbor.id ) )
        {
          //console.log("calling recursive");
          // call the function recursively to traverse further from neighbor
          dfs( neighbor );
        }
        else if( visitedCatalog[neighbor.id] === 'gray' )
        {
          // console.log("loop found at=" + neighbor.id);
        }
      });      
    }
    else
    {
      // the node is a leaf, one result found
      // console.log( "leaf found:" );
      // console.log( d3.select("#" + neighbor.id  + ".nodeGroup" ) );
      // ++leafs;
      // console.log( "stack:");
      // console.log( traversingStack );
      // console.log( "paths:" );

      //shallowCopyObject = $.extend({}, traversingStack);
      shallowCopyObject = traversingStack.slice(0);
      pathLength = shallowCopyObject.length;
      if( pathLength > maxPathLength ) maxPathLength = pathLength;
      simplePaths.push( shallowCopyObject );
      // console.log( simplePaths );
    }
    // console.log("delete 1 from stack");
    traversingStack.pop();
    visitedCatalog[nodeO.id] = 'black';
  };

  // mark down links that leave from each node
  edges.each( function(d,i)
  {
    linkSourceDestCatalog[ d.source.id + "|" + d.target.id ] = d;
    // if( !nodeLinkCatalog.hasOwnProperty( d.target.id ) )
    // {
    //   nodeLinkCatalog[ d.target.id ] = [];
    // }
    // nodeLinkCatalog[ d.target.id ].push( d );
    if( !nodeLinkCatalog.hasOwnProperty( d.source.id ) )
    {
      nodeLinkCatalog[ d.source.id ] = [];
    }
    nodeLinkCatalog[ d.source.id ].push( d );
  });

  // do a DFS search to get the simple paths in the graph:
  dfs( refNode );
  //console.log("LEAFS=" + leafs);
  //console.log( jea = simplePaths );
  // console.log( stack = traversingStack );
  // console.log( paths = simplePaths );

// draw the table

    var tableConfig = {
        "bProcessing": true,
        "aaData": [],
        "sScrollX": "100%",
        // "sScrollXInner": "120%",
        // "bScrollCollapse": true,        
        "bJQueryUI": true,
        "sDom": '<"H"lfr>t<"F"Cip>',
        "iDisplayLength": 100,
        "aoColumns": [ 
        { "sTitle": "score", "mData": "score" } ],
        // desc order of score
        "aaSorting": [[0, "desc"]]
    };
        $("#pathTab").html( '<table id="pathTable" cellpadding="0" cellspacing="0" border="0"></table>' );

        $.each( simplePaths, function(indP, pathElements)
        {
          pathLinks = [];
          pathCell = {};
          $.each( pathElements, function(indN,nodeO)
          {
            pathCell['node' + (indN+1)] = getNodeHTML( nodeO ); //nodeO.label;
            if( ( indN+1 ) < pathElements.length )
            {
              pathCell['link' + (indN+1)] = getLinkHTML( linkSourceDestCatalog[ nodeO.id + "|" + pathElements[indN+1].id ] ) //.pvalue.toFixedDown(2);
            }

          });
          // find links, used to calculate score
          for( var i = 1; i < pathElements.length; ++i )
          {
            pathLinks.push( linkSourceDestCatalog[ pathElements[i-1].id + "|" + pathElements[i].id ] );
          }
          pathCell['score'] = d3.mean( pathLinks, function(d) { return d.pvalue; } ).toFixedDown(2);
          tableConfig["aaData"].push( pathCell );
        });

        for( var pathNum = 1; pathNum <= maxPathLength; ++pathNum )
        {
          tableConfig.aoColumns.push( { "sTitle": "node" + pathNum, "mData": "node" + pathNum, "sType": "html" } );
          if( pathNum < maxPathLength )
          {
            tableConfig.aoColumns.push( { "sTitle": "link" + pathNum, "mData": "link" + pathNum } );
          }
        }

    var oTable = $('#pathTab #pathTable').dataTable( tableConfig );

};


var initHeatmap = function()
{

  // don't redraw on every click
  if( heatMapDrawn )
  {
    console.log("won't redraw");
    return;
  }

  // heatmap index
  if( $('#headertabs').tabs('option','selected') !== 1 )
  {
    // don't draw if tab is not shown
    return;
  }
  openDialog( "Updating heatmap", "Updating heatmap, please wait.");

  console.log( "initheatmap called ");
  if( patientBarcodes.length === 0 )
  {
    openDialog("No graph data", "To draw a heatmap of the graph, first initialize the suitable graph.")
    return;
  }

  var nodes = d3.selectAll('.nodeGroup').data();
  if( nodes.length === 0 )
  {
    openDialog("Empty graph", "The graph does not contain nodes.");
    return;
  }

  var edges = d3.selectAll('line.link').data();
  var refNode = d3.select(".nodeGroup#n" + referenceNodeId ).data()[0];

  var neighbors = [];
  var patients = [];
  var heatmapConfig = {
    container: 'heatmapTab',
    margins: { 'left': 20, 'top': 20, 'right': 50, 'bottom': 20 },
    labelRotation: -40,
    sidepanelLabelRotation: -40,
    colors: {
      sampleClass: {
        startColor: d3.rgb('blue'),
        endColor: d3.rgb('red')
      },
      C: {
        startColor: d3.rgb('blue'),
        endColor: d3.rgb('red')
      },
      N: {
        GEXP: {
          startColor: d3.rgb('green'),
          endColor: d3.rgb('red')          
        },
        RPPA: {
          startColor: d3.rgb('green'),
          endColor: d3.rgb('red')          
        },
        CNVR: {
          range: [-1,1],
          startColor: d3.rgb('blue'),
          middleColor: d3.rgb('white'),
          endColor: d3.rgb('red')          
        },
        METH: {
          range: [0,1],
          startColor: d3.rgb('white'),
          endColor: d3.rgb('orange')          
        },
        other: {
          startColor: d3.rgb('blue'),
          endColor: d3.rgb('red')          
        },
      }
    }
  };
  var patientObj;

  // sort by pvalue
  edges.sort( function(a,b) { 
    if( +a['pvalue'] < +b['pvalue'] )
    {
      return 1;
    }
    if( +a['pvalue'] > +b['pvalue'] )
    {
      return -1;
    }
    return 0;
  });

  // refnode is leftmost
  neighbors.push( refNode );
  $.each( edges, function(ind, edge)
  {
    if( edge.source.id === refNode.id )
    {
      neighbors.push( edge.target );
    }
  });

  $.each( patientBarcodes, function(ind,barcode)
  {
    patientObj = { 'name': barcode };
    if( patientSampleClassifications.length > 0 )
    {
      patientObj['class'] = patientSampleClassifications[ind];
    }
    patients.push( patientObj );
  });

  renderHeatmap( patients, neighbors, refNode, heatmapConfig );
  heatMapDrawn = true;
  closeDialog();
};


var updateSampleClassifications = function()
{
      // get patient value classifications, if any
      $.ajax( {
        type: "POST",
        url: '/graph/getSampleData',
        // wait for this to complete
        async: false,
        data: JSON.stringify( { datalabel: $('select#datasetSelection > option:selected').val() } ),
        dataType: "json",
        contentType: "application/json",
        success: function( result )
        { 
          patientSampleClassifications = result.samples;
        }
      });
};

    function onLoad() {

      // quickfix: remove padding enforced by accordion
      $('.filterTab').css('padding-left', 0);
      $('.filterTab').css('padding-right', 0);
      $('.filterTab').css('padding-top', 20);
      $('.filterTab').css('padding-bottom', 20);


      // header tabs with jquery tabs
      $( "#headertabs" ).tabs();

      // select menu for datasets
      $('select#datasetSelection').selectmenu({
        style:'dropdown', 
        format: addressFormatting,
        menuWidth: 200,
        change: function() {
          console.log("dataset change");
          heatMapDrawn = false;
          updateClinNodes();
          updatePatientBarcodes();
          updateSampleClassifications();
        }
      });

    //a custom format option callback
    var addressFormatting = function(text){
      var newText = text;
      //array of find replaces
      var findreps = [
        {find:/^([^\-]+) \- /g, rep: '<span class="ui-selectmenu-item-header">$1</span>'},
        {find:/([^\|><]+) \| /g, rep: '<span class="ui-selectmenu-item-content">$1</span>'},
        {find:/([^\|><\(\)]+) (\()/g, rep: '<span class="ui-selectmenu-item-content">$1</span>$2'},
        {find:/([^\|><\(\)]+)$/g, rep: '<span class="ui-selectmenu-item-content">$1</span>'},
        {find:/(\([^\|><]+\))$/g, rep: '<span class="ui-selectmenu-item-footer">$1</span>'}
      ];
      
      for(var i in findreps){
        newText = newText.replace(findreps[i].find, findreps[i].rep);
      }
      return newText;
    }

      // get datalabels for the dropdown menu:
      $.ajax( {
        url: '/graph/getDatasets',
        dataType: 'json',
        async: false,
        success: function(json) {
        html = '';
        $.each( json['datalabels'], function(ind, ele) {
          html += '<option value="' + ele + '">' + ele + '</option>';
        });
        $('select#datasetSelection').html( html );
        $('select#datasetSelection').selectmenu({ 'refresh': true });
        updatePatientBarcodes();
        }

      });

      // show only filtering tab
      $('#sidebar').multiAccordion( { active: 0 } );

      $('#filter').tabs( { selected: '#clinSearch' });


      // when tab link is clicked...      
      $('#headertabs > ul > li a[href="#heatmapTab"]').bind('click', 
        function() { 
          initHeatmap();
      } );
      // when tab link is clicked...
      $('#headertabs > ul > li a[href="#pathTab"]').bind('click', function() { initPaths() } );



      // free text search tab:
      $("#freeSearch > input[type=submit]").bind("click", function(caller)
      {
        var query = { nodeLabel: $('input[id=labelSearch]').val(),
        nodeType: $('select[id=nodeType]').val(), datalabel: $('select#datasetSelection > option:selected').val() };
        // check the node exists before continuing
        $.ajax( {
          type: "POST",
          url: '/graph/nodeExists',
          data: JSON.stringify( query ),
          dataType: "json",
          contentType: "application/json",
          success: function( result )
          {
              if( result['nodeExists'] === false )
              {
                openDialog("Invalid node label", "Node label does not exist");
                //alert("Node label does not exist.")
                return;
              }

              var neighborhoodQuery = { 
                nodeLabel: $('#freeSearch > input[id=labelSearch]').val(), 
                nodeType: $('#freeSearch > select[id=nodeType]').val(),
                depth: $('#freeSearch > select[id=depth]').val(),
                nodes: $('#freeSearch > select[id=nodes]').val(),
                edgeType: $('#freeSearch > select[id=edgeType]').val(),
                edgeOrdering: $('#freeSearch > select[id=edgeOrdering]').val(),
                edgeOrderingAttribute: $('#freeSearch > select[id=edgeOrderingAttribute]').val(),
                datalabel: $('select#datasetSelection > option:selected').val(),
              };

              if( result['nodes'].length > 0 )
              {
                openTableDialog("Several node labels found", "Select suitable node as a starting node", result.nodes );
                return;
              }

              if( $('#freeSearch > select[id="firstEdgeType"]').val() !== 'Any' )
              {
                neighborhoodQuery['firstEdgeType'] = $('#freeSearch > select[id="firstEdgeType"]').val();
              }

              if( $('#freeSearch > select[id="secondEdgeType"]').val() !== 'Any' )
              {
                neighborhoodQuery['secondEdgeType'] = $('#freeSearch > select[id="secondEdgeType"]').val();
              }

              openDialog( "Loading", 'Loading graph data, please wait.<br><br><img src="waiting-small.gif" style="display: block; margin-left: auto; margin-right: auto;" />');              
              $.ajax( {
                        type: "POST",
                        url: '/graph/neighborhood',
                        data: JSON.stringify( neighborhoodQuery ),
                        dataType: "json",
                        contentType: "application/json",
                        success: function( result )
                        {
                            heatMapDrawn = false;
                            referenceNodeId = result.referenceNode;
                            if( result.nodes.length === 0 )
                            {
                              openDialog("Empty graph", "The resulting graph does not contain any nodes.")
                              return;
                            }
                            closeDialog();                       
                            initGraph( result, patientBarcodes );
                            // will check if drawing is necessary
                            initHeatmap();
                        },
                        failure: function( errMsg )
                        {
                          closeDialog();
                          console.log( errMsg );
                       }
                     } );
            },
          failure: function( errMsg )
          {
            console.log( errMsg );
          }

        });
      });


      // 'affects' search:
      $('#regulatory input[type="submit"]').bind("click", function(caller)
      {
          var query = { 
            datalabel: $('select#datasetSelection > option:selected').val(),

            clinicalNodeId: $('#regulatory select[name="nodeName"] option:selected').val(),
            middleNodeType: $("#regulatory #middleNodeType option:selected").attr("id"),
            targetType: $('#regulatory select#sourceNodeType option:selected').attr('id'),
            mutatedType: $('#regulatory select#sourceNodeType option:selected').attr('type'),
            distanceThreshold: 100000,
          };

          if( query.targetType === 'METH' )
          {
            query['gexpTargetCorrelationType'] = 'negative';
          }
          else if( query.targetType === 'CNVR' )
          {
            query['gexpTargetCorrelationType'] = 'positive';
          }
          else if( query.targetType === 'MIRN' )
          {
            query['gexpTargetCorrelationType'] = 'negative';
          }

          openDialog( "Loading", 'Loading graph data, please wait.<br><br><img src="waiting-small.gif" style="display: block; margin-left: auto; margin-right: auto;" />');
          $.ajax( {
                    type: "POST",
                    url: '/graph/regulatoryPattern',
                    data: JSON.stringify( query ),
                    dataType: "json",
                    contentType: "application/json",
                    success: function( result )
                    {
                        heatMapDrawn = false;
                        closeDialog();
                        if( result.nodes.length === 0 )
                        {                          
                          openDialog("Empty graph", "The resulting graph does not contain any nodes.");
                          return;
                        }
                        referenceNodeId = result.referenceNode;                        
                        initGraph( result, patientBarcodes );

                        // will check if drawing is necessary
                        initHeatmap();
                    },
                    failure: function( errMsg )
                    {
                      closeDialog();
                      console.log( errMsg );
                   }
                 } );

        });

      // clinical search:
      $("#clinSelect > input[type=submit]").bind("click", function(caller)
      {
              var neighborhoodQuery = { 
                nodeId:  $("#clinSelect > select[name='nodeName'] > option:selected").attr('value'),
                //nodeLabel: $("#clinSelect > select[name='nodeName']").val(), 
                nodeType: 'CLIN',
                depth: $('#clinSelect > select[id=depth]').val(),
                nodes: $('#clinSelect > select[id=nodes]').val(),
                edgeType: $('#clinSelect > select[id=edgeType]').val(),
                edgeOrdering: $('#clinSelect > select[id=edgeOrdering]').val(),
                edgeOrderingAttribute: $('#clinSelect > select[id=edgeOrderingAttribute]').val(),
                datalabel: $('select#datasetSelection > option:selected').val(),
              };

              if( $('#clinSelect > select[id="firstEdgeType"]').val() !== 'Any' )
              {
                neighborhoodQuery['firstEdgeType'] = $('#clinSelect > select[id="firstEdgeType"]').val();
              }

              if( $('#clinSelect > select[id="secondEdgeType"]').val() !== 'Any' )
              {
                neighborhoodQuery['secondEdgeType'] = $('#clinSelect > select[id="secondEdgeType"]').val();
              }

              openDialog( "Loading", 'Loading graph data, please wait.<br><br><img src="waiting-small.gif" style="display: block; margin-left: auto; margin-right: auto;" />');
              $.ajax( {
                        type: "POST",
                        url: '/graph/neighborhood',
                        data: JSON.stringify( neighborhoodQuery ),
                        dataType: "json",
                        contentType: "application/json",
                        success: function( result )
                        {
                            heatMapDrawn = false;
                            referenceNodeId = result.referenceNode;
                            closeDialog();
                            if( result.nodes.length === 0 )
                            {
                              openDialog("Empty graph", "The resulting graph does not contain any nodes.");
                              return;
                            }
                            initGraph( result, patientBarcodes );
                            // will check if drawing is necessary
                            initHeatmap();
                        },
                        failure: function( errMsg )
                        {
                          closeDialog();
                          console.log( errMsg );
                       }
                     } );

        });

      var updateClinNodes = function( firstUpdate ) {
        firstUpdate = firstUpdate || false;

        // get clinical node names
        $('#clinSelect').prepend('<img src="waiting-small.gif" style="display: block; margin-left: auto; margin-right: auto;" />');
        $('#regulatory p').append('<img src="waiting-small.gif" style="display: block; margin-left: auto; margin-right: auto;" />');
        $.ajax( {
                type: "POST",
                url: '/graph/getCLINNodes',
                dataType: "json",
                async: false,
                data: JSON.stringify( { datalabel: $('select#datasetSelection > option:selected').val() } ),
                contentType: "application/json",
                success: function( json )
                {
                  $('#clinSelect > img').remove();
                  $('#regulatory p > img').remove();
                  if( firstUpdate ) {
                    var html = '<select name="nodeName">';
                    // alphabetical order:
                    $.each( json['nodes'].sort( orderObjectBy('label') ), function(ind,ele)
                    {
                      html += '<option value="' + ele.id + '">' + ele.label + "</option>"
                    } );
                    html += "</select><br>";
                    $('#clinSelect select[name="nodeName"]').replaceWith( html );
                    //$('#clinSelect').prepend( html );
                    $('#regulatory p').append( html );               
                  }
                  else
                  {
                    var html = '<select name="nodeName">';
                    $.each( json['nodes'].sort( orderObjectBy('label') ), function(ind, ele) {
                      html += '<option value="' + ele.id + '">' + ele.label + "</option>"
                    } );
                    html += "</select>";
                    $('#clinSelect > select[name="nodeName"]').replaceWith(html);
                    $('#regulatory p > select[name="nodeName"]').replaceWith(html);
                  }
                },
                failure: function( errMsg )
                {
                  console.log( errMsg );
               }
             } );
      };

      // on pageload delay so dropdown list has elements
      setTimeout( function() { updateClinNodes( true ) }, 250 );


      //dialog stuff
      $('#dialog').dialog({
      autoOpen: false,
      width: 'auto',//width: 300,
      height: 'auto',
      resizable: true,
      show: {effect: 'fade', duration: 200},
      hide: {effect: 'fade', duration: 200},
      modal: true,
      closeOnEscape: true,
      // close dialogs if background is clicked
      open: function(){
          jQuery('.ui-widget-overlay').bind('click',function(){
              jQuery('#dialog').dialog('close');
          })
      },
      buttons: {
        "Close": function() {
        $(this).dialog("close");
        },
      },

      });
    }

    </script>
  </head>

  <body onload="onLoad()">

    <div class="container">
        <div class="ui-widget-content ui-corner-top" style="height: 50px; margin-top: 0px">
          <div id="dataset" style="float:left; margin-left: 20px; margin-top: 8px;">
            <label for="dataset">Select a dataset:</label>
            <select name="dataset" id="datasetSelection">
            </select>
          </div>
          <div id="header">
            <h2 id="forcedirected_graph" style="text-align: center;">Force-Directed Graph</h2>
          </div>
        </div>

      <div id="headertabs">
        <ul>
          <li><a href="#graphTab">Graph</a></li>
          <li><a href="#heatmapTab">Heatmap</a></li> 
          <li><a href="#pathTab">Paths</a></li> 
        </ul>
        <div id="graphTab" class="headertab">
        </div>
        <div id="heatmapTab">
            <div id="sampleclass_container"></div>
            <div id="categorical_container"></div>
            <div id="numerical_container"></div>
        </div>
        <div id="pathTab"></div>
      </div>
      <div id="sidebar">
        <h3><a href="#">Filtering settings</a></h3>
        <div id="filter" class="sidetab">

          <ul>
            <li><a href="#clinSelect">Clinical</a></li>
            <li><a href="#freeSearch">Text search</a></li>
            <li><a href="#regulatory">Regulatory</a></li>
          </ul>

          <div id="clinSelect" class="filterTab">
            <!-- template will be added here -->
          </div>

          <div id="freeSearch" class="filterTab">
            Start node label: <input type="text" id="labelSearch" size="15" placeHolder="node label"/><br>
            Node type:
            <select id="nodeType" size="1" class="nodeType">
              <option>CLIN</option>
              <option>GEXP</option>
              <option>CNVR</option>
              <option>METH</option>
              <option>GNAB</option>
              <option>SAMP</option>
              <option>MIRN</option>
              <option>RPPA</option>
            </select>
            <br>
            Traversal depth:
            <select id="depth" size="1">
              <option>1</option>
              <option>2</option>
              <option selected="selected">3</option>
              <option>4</option>
            </select>

            <select id="firstEdgeType" size="1" class="nodeType">
              <option>Any</option>
              <option>CLIN</option>
              <option>GEXP</option>
              <option>CNVR</option>
              <option>METH</option>
              <option>GNAB</option>
              <option>SAMP</option>
              <option>MIRN</option>
              <option>RPPA</option>
            </select>

            <select id="secondEdgeType" size="1" class="nodeType">
              <option>Any</option>
              <option>CLIN</option>
              <option>GEXP</option>
              <option>CNVR</option>
              <option>METH</option>
              <option>GNAB</option>
              <option>SAMP</option>
              <option>MIRN</option>
              <option>RPPA</option>
            </select>
            <br>

            Nodes per layer:
            <select id="nodes" size="1">
              <option>5</option>
              <option>6</option>
              <option>7</option>
              <option>8</option>
              <option>9</option>
              <option>10</option>
            </select>
            <br>
            Ordering criterion:
            <select id="edgeOrderingAttribute" size="1">
              <option selected="selected">pvalue</option>
              <option>distance</option>
              <option>correlation</option>
              <option>importance</option>
            </select>
            <select id="edgeOrdering" size="1">
              <option selected="selected">DESC</option>
              <option>ASC</option>
            </select>
            <br>
            <input id="searchButton" type="submit" value="Search">
          </div>

          <div id="regulatory" class="filterTab">
            <!-- template will be added here -->
          </div>
        </div>


        <h3><a href="#">Node A</a></h3>
        <div id="nodeA" class="sidetab" >
        </div>

        <h3><a href="#">Node B</a></h3>

        <div id="nodeB" class="sidetab">
        </div>

        <h3><a href="#">Link</a></h3>

        <div id="link" class="sidetab">
        </div>

        <h3><a href="#">Plot</a></h3>
        <div id="plot" class="sidetab">
        </div>

        <!-- only show when needed later -->
        <h3 style="display: none;"><a href="#">Box plot information</a></h3>
        <div id="boxplotinfo" class="sidetab">
        </div>        

      </div>
    </div>

    <!-- dialog stuff -->
    <div id="dialog">
    </div>

  </body>
  </html>